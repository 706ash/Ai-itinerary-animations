<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maldives Chatbot</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/3.5.0/remixicon.min.css"
        integrity="sha512-/VYneElp5u4puMaIp/4ibGxlTd2MV3kuUIroR3NSQjS2h9XKQNebRQiyyoQKeiGE9mRdjSCIZf9pb7AVJ8DhCg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;500;600;700;800;900&family=Poppins:wght@4400;500;600;700;800;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden; /* Prevent scrollbars */
        }

        body {
            font-family: "Poppins", sans-serif;
            background: #106667;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* For positioning children */
        }

        #background-image-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* background-image: linear-gradient(to right, #FF8C00, #FF6347, #DA70D6, #8A2BE2); */
            background-image: url('maldives.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 0; /* Ensure it's behind other content */
        }

        /* Typing Indicator and Chat Input Styles */
        #typing-indicator {
            width: 200px;
            height: 60px;
            background: rgba(0, 188, 212, 0.8); /* Slightly transparent */
            border-radius: 20px;
            position: fixed; /* Fixed position to overlay */
            bottom: 100px; /* Adjust position as needed */
            left: 50%;
            transform: translateX(-50%);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101; /* Above background */
        }

        #typing-indicator span {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            margin: 0 5px;
            animation: bounce 1s infinite ease-in-out;
        }
        #typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }
        #typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0.8); }
            40% { transform: scale(1.2); }
        }

        #chat-input {
            width: 80%;
            max-width: 500px;
            min-height: 50px; /* Ensure enough height for contenteditable */
            padding: 15px;
            border: none; /* Remove original border */
            border-radius: 25px; /* More rounded */
            font-size: 1.2em;
            outline: none;
            /* Gradient outline using multiple box-shadows */
            box-shadow:
                0 8px 32px 0 rgba(31, 38, 135, 0.37); /* Existing glassmorphic shadow */
            background: rgba(255, 255, 255, 0.1); /* More transparent background */
            backdrop-filter: blur(10px); /* Glassmorphic blur effect */
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            position: fixed; /* Fixed position to overlay */
            bottom: 30px; /* Adjust position as needed */
            left: 50%;
            transform: translateX(-50%);
            z-index: 101; /* Above background */
            color: #fff; /* Text color for better contrast */
            white-space: pre-wrap; /* Preserve whitespace and allow wrapping */
            word-wrap: break-word; /* Break long words */
        }

        #chat-input:empty:before {
            content: attr(placeholder);
            color: rgba(255, 255, 255, 0.7);
        }

        /* Wave Button Styles (based on demo) */
        #send-button {
            color: #fff;
            text-decoration: none;
            border: none; /* Remove original border */
            border-radius: 50%; /* Circular */
            font-family: Helvetica, sans-serif; /* From demo */
            font-weight: 600;
            font-size: 1.5em; /* Adjusted icon size for smaller button */
            line-height: 1; /* Adjust line height for icon centering */
            position: fixed;
            bottom: 30px; /* Align with chat input */
            left: calc(50% + 250px + 10px); /* Position to the right of input with a gap */
            width: 50px; /* Small size */
            height: 50px; /* Small size */
            overflow: hidden;
            transition: all 0.3s;
            z-index: 102;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Themed background and shadow */
            box-shadow:
                0 8px 32px 0 rgba(31, 38, 135, 0.37); /* Existing glassmorphic shadow */
            background: rgba(255, 255, 255, 0.1); /* Transparent background */
            backdrop-filter: blur(10px); /* Glassmorphic blur effect */
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            cursor: pointer;
        }

        #send-button:before {
            content: '';
            position: absolute;
            width: 180px; /* Scaled for small circular button */
            height: 180px; /* Scaled for small circular button */
            border-radius: 79px; /* Scaled for small circular button */
            background-color: #fff;
            top: 90%; /* Start mostly hidden */
            left: 50%; /* From demo */
            animation: wave 5s infinite linear;
            transition: all 1s;
            z-index: -1;
        }

        @keyframes wave {
            0% {
                transform: translateX(-50%) rotate(0deg);
            }
            100% {
                transform: translateX(-50%) rotate(360deg);
            }
        }

        #send-button:hover {
            color: #00bcd4; /* Change icon color to match theme */
        }

        #send-button:hover:before {
            top: 50%; /* Bring wave to semi-fill on hover */
        }

        #send-button i {
            /* Remixicon styling */
            line-height: 1;
        }

        #emoji-picker {
            position: absolute; /* Will be positioned dynamically by JS */
            background: rgba(255, 255, 255, 0.1); /* More transparent background */
            backdrop-filter: blur(10px); /* Glassmorphic blur effect */
            -webkit-backdrop-filter: blur(10px); /* For Safari */
            border-radius: 10px;
            box-shadow:
                0 8px 32px 0 rgba(31, 38, 135, 0.37); /* Existing glassmorphic shadow */
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            z-index: 103; /* Above chat-input */
        }

        .emoji-button {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background 0.2s;
        }

        .emoji-button:hover {
            background: rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>

    <div id="background-image-container"></div>

    <div id="chat-input" contenteditable="true" placeholder="Type your message here..."></div>

    <button id="send-button"><i class="ri-water-fill"></i></button>

    <div id="emoji-picker" style="display: none;">
        <!-- Emojis will be populated here by JavaScript -->
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="jquery.ripples.js"></script>
    <script>

        // Initialize ripples on the background image container
        $('#background-image-container').ripples({
            resolution: 1080,
            perturbance: 0.02,
            interactive: false // Set to false to control programmatically
        });

        // Function to get caret coordinates
        function getCaretCoordinates() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0).cloneRange();
                range.collapse(false); // Collapse to the end of the range (caret position)
                const rect = range.getClientRects()[0];
                if (rect) {
                    return { x: rect.left, y: rect.top };
                }
            }
            return null;
        }

        // Listen for input events on the contenteditable div
        $('#chat-input').on('input', function(e) {
            const backgroundContainer = $('#background-image-container');
            
            if (backgroundContainer) {
                const ripplesInstance = backgroundContainer.data('ripples');

                if (ripplesInstance) {
                    const caretCoords = getCaretCoordinates();

                    if (caretCoords) {
                        // Get the position of the background element relative to the viewport
                        const bgOffset = backgroundContainer.offset();

                        // Calculate ripple coordinates relative to the background element
                        const rippleX = caretCoords.x - bgOffset.left;
                        const rippleY = caretCoords.y - bgOffset.top;

                        // Trigger a ripple at the caret's position
                        ripplesInstance.drop(rippleX, rippleY, 20, 0.04); // Adjust radius/perturbance as needed
                    }
                }
            }
        });

        // Handle placeholder for contenteditable div
        const chatInputDiv = document.getElementById('chat-input');
        chatInputDiv.addEventListener('focus', function() {
            if (this.textContent === this.getAttribute('placeholder')) {
                this.textContent = '';
                this.classList.remove('placeholder-active');
            }
        });
        chatInputDiv.addEventListener('blur', function() {
            if (this.textContent === '') {
                this.textContent = this.getAttribute('placeholder');
                this.classList.add('placeholder-active');
            }
        });
        // Initial placeholder setup
        if (chatInputDiv.textContent === '') {
            chatInputDiv.textContent = chatInputDiv.getAttribute('placeholder');
            chatInputDiv.classList.add('placeholder-active');
        }

        // Click event for the send button to create a big ripple
        $('#send-button').on('click', function() {
            const backgroundContainer = $('#background-image-container');
            const sendButton = $('#send-button');

            if (backgroundContainer) {
                const ripplesInstance = backgroundContainer.data('ripples');

                if (ripplesInstance) {
                    const buttonOffset = sendButton.offset();
                    const buttonWidth = sendButton.outerWidth();
                    const buttonHeight = sendButton.outerHeight();

                    const bgOffset = backgroundContainer.offset();

                    // Calculate center of the button relative to the background container
                    const rippleX = (buttonOffset.left + buttonWidth / 2) - bgOffset.left;
                    const rippleY = (buttonOffset.top + buttonHeight / 2) - bgOffset.top;

                    console.log('Button center (relative to document):', buttonOffset.left + buttonWidth / 2, buttonOffset.top + buttonHeight / 2);
                    console.log('Background offset (relative to document):', bgOffset.left, bgOffset.top);
                    console.log('Calculated ripple coordinates (relative to background):', rippleX, rippleY);

                    // Trigger a big ripple
                    ripplesInstance.drop(rippleX, rippleY, 20, 0.2); // Smaller radius, reduced perturbance for cleanliness
                }
            }
        });

        // Emoji data (a simple list for demonstration)
        const emojis = [
            '😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '😊', '😇',
            '🙂', '🙃', '😉', '😌', '😍', '🥰', '😘', '😗', '😙', '😚',
            '😋', '😛', '😜', '🤪', '😝', '🤑', '🤗', '🤭', '🤫', '🤔',
            '🤐', '🤨', '😐', '😑', '😶', '😏', '😒', '🙄', '😬', '🤥',
            '😌', '😔', '😪', '🤤', '😴', '😷', '🤒', '🤕', '🤢', '🤮',
            '🤧', '🥵', '🥶', '🥴', '😵', '🤯', '🤠', '🥳', '😎', '🤓',
            '🧐', '😕', '😟', '🙁', '☹️', '😮', '😯', '😲', '😳', '🥺',
            '😦', '😧', '😨', '😰', '😥', '😢', '😭', '😱', '😖', '😣',
            '😞', '😓', '😩', '😫', '😤', '😡', '😠', '🤬', '😈', '👿',
            '💀', '☠️', '💩', '🤡', '👹', '👺', '👻', '👽', '👾', '🤖',
            '😺', '😸', '😹', '😻', '😼', '😽', '🙀', '😿', '😾'
        ];

        const chatInput = $('#chat-input');
        const emojiPicker = $('#emoji-picker');
        let lastColonIndex = -1;

        // Function to get caret position in contenteditable div
        function getCaretPosition(element) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element[0]);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                return preCaretRange.toString().length;
            }
            return 0;
        }

        // Function to set caret position in contenteditable div
        function setCaretPosition(element, pos) {
            const range = document.createRange();
            const selection = window.getSelection();
            let charCount = 0;
            let found = false;

            function traverseNodes(node) {
                if (found) return;
                if (node.nodeType === Node.TEXT_NODE) {
                    const nextCharCount = charCount + node.length;
                    if (pos <= nextCharCount) {
                        range.setStart(node, pos - charCount);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        found = true;
                    }
                    charCount = nextCharCount;
                } else {
                    for (let i = 0; i < node.childNodes.length; i++) {
                        traverseNodes(node.childNodes[i]);
                    }
                }
            }
            traverseNodes(element[0]);
        }


        // Populate emoji picker
        function populateEmojiPicker() {
            emojiPicker.empty();
            emojis.forEach(emoji => {
                const button = $('<button>')
                    .addClass('emoji-button')
                    .text(emoji)
                    .on('click', function() {
                        insertEmoji(emoji);
                        emojiPicker.hide();
                    });
                emojiPicker.append(button);
            });
        }

        // Insert emoji into contenteditable div
        function insertEmoji(emoji) {
            const currentText = chatInput.text();
            const caretPos = getCaretPosition(chatInput);

            // Remove the colon and any text after it that was part of the trigger
            let textBeforeColon = currentText.substring(0, lastColonIndex);
            let textAfterColon = currentText.substring(caretPos); // Keep text after current caret

            // Reconstruct the text
            const newText = textBeforeColon + emoji + textAfterColon;
            chatInput.text(newText);

            // Set caret position after the inserted emoji
            setCaretPosition(chatInput, lastColonIndex + emoji.length);

            // Reset lastColonIndex
            lastColonIndex = -1;
        }

        // Show/hide and position emoji picker
        function showEmojiPicker(coords) {
            // Temporarily show to get accurate height
            emojiPicker.css({ visibility: 'hidden', display: 'block' });
            const pickerHeight = emojiPicker.outerHeight();
            emojiPicker.css({ visibility: 'visible', display: 'none' }); // Hide it again

            const chatInputHeight = chatInput.outerHeight();
            const chatInputBottom = 30; // From CSS: #chat-input has bottom: 30px;

            // Calculate bottom position for the emoji picker
            const pickerBottom = chatInputBottom + chatInputHeight + 10; // 10px gap above chat input

            emojiPicker.css({
                bottom: pickerBottom,
                left: coords.x, // Keep left relative to caret
                top: 'auto' // Clear top property
            }).show();
            populateEmojiPicker();
        }

        function hideEmojiPicker() {
            emojiPicker.hide();
            lastColonIndex = -1; // Reset when hidden
        }

        // Listen for input events on the contenteditable div
        chatInput.on('input', function(e) {
            const text = chatInput.text();
            const caretPos = getCaretPosition(chatInput);

            // Check if the last character typed is a colon
            if (text.charAt(caretPos - 1) === ':') {
                lastColonIndex = caretPos - 1;
                const caretCoords = getCaretCoordinates(); // Re-using existing function
                if (caretCoords) {
                    showEmojiPicker(caretCoords);
                }
            } else if (lastColonIndex !== -1 && (caretPos <= lastColonIndex || text.charAt(lastColonIndex) !== ':')) {
                // If colon was typed but then deleted or moved away from, hide picker
                hideEmojiPicker();
            } else if (lastColonIndex !== -1 && text.charAt(lastColonIndex) === ':') {
                // If still within the colon context, but not typing a new colon, keep picker open
                // but update its position if needed (e.g., if user types more after colon)
                const caretCoords = getCaretCoordinates();
                if (caretCoords) {
                    emojiPicker.css({
                        top: caretCoords.y + 20,
                        left: caretCoords.x
                    });
                }
            } else {
                // Hide if no colon context
                hideEmojiPicker();
            }

            // Existing ripples logic
            const backgroundContainer = $('#background-image-container');
            if (backgroundContainer) {
                const ripplesInstance = backgroundContainer.data('ripples');
                if (ripplesInstance) {
                    const caretCoords = getCaretCoordinates();
                    if (caretCoords) {
                        const bgOffset = backgroundContainer.offset();
                        const rippleX = caretCoords.x - bgOffset.left;
                        const rippleY = caretCoords.y - bgOffset.top;
                        ripplesInstance.drop(rippleX, rippleY, 20, 0.04);
                    }
                }
            }
        });

        // Hide emoji picker when clicking outside
        $(document).on('click', function(e) {
            if (!$(e.target).closest('#emoji-picker').length && !$(e.target).closest('#chat-input').length) {
                hideEmojiPicker();
            }
        });

        // Hide emoji picker on escape key
        $(document).on('keydown', function(e) {
            if (e.key === 'Escape') {
                hideEmojiPicker();
            }
        });
    </script>
</body>

</html>